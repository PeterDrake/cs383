# CS #83 Algorithm Design & Analysis
Fall 2025

**Instructor**: [Peter Drake](https://sites.google.com/a/lclark.edu/drake/home)  
**Teaching assistant**: [Olivia Townsend](mailto:oliviatownsend@lclark.edu)  
**Meetings**: 11:30 AM - 12:30 PM MWF, Olin 305  
**Final presentations**: 1-4 PM, Tuesday, December 16

## Getting Help
* Write to the [course email list](mailto:25fa-cs-383-01@lclark.edu) 24/7
* Come to the TA's lab hours, TBA
* [Make an appointment to see me](https://calendar.app.google/qegvZRaPJ5mScdCz5) or drop by my office

## Course Text
Roughgarden, [*Algorithms Illuminatd: Omnibus Edition*](https://www.algorithmsilluminated.org/)
### Suggested Texts
No readings will be assigned, but if you want another take on a topic or to read more deeply, here is one option:  

Miller, Ranum, and Yazinovskyy, [*Problem Solving with Algorithms and Data Structures using Python, Third Edition*](https://runestone.academy/ns/books/published/pythonds3/) (free online)

## Links
[Course Policies](https://github.com/PeterDrake/drakepedia/blob/master/administrivia/policies.md)  
[Class Notes](https://github.com/PeterDrake/cs383/tree/main/lessons)  
[In-Class Code](https://github.com/PeterDrake/cs383_f25_in_class)  
[Pythonorama](https://github.com/alainkaegi/pythonorama/blob/main/README.md)

## Overview
You already know, at some level, everything you need to solve any computational problem. Algorithm Design and Analysis gives you the more powerful tools needed to solve computational problems *efficiently*. For small problems, an efficient program is more pleasant to use, as it responds in a fraction of a second rather than in minutes. For more complicated problems, an inefficient program may require so much time or memory that it is effectively *unusable*. Ingenious techniques for the design and analysis of algorithms will allow you to tackle these challenging problems.

## Learning Objectives and Themes
Upon completing this course, you should be able to:
* formally analyze the time and space complexity of various algorithms and data structures.
* select and design appropriate algorithms for solving computational problems.
* use, implement, explain, and compare various data structures and algorithms. Data structures include stacks, queues, lists, sets, trees (including several variations of binary trees), graphs, and hash tables. Implementations include array-based and linked versions. Algorithms include sorting, searching, graph, and string algorithms.

We will often revisit four major algorithm design strategies:
* Brute force (try all the possibilities)
* Transform (turn the problem into a different one)
* Divide and conquer (solve smaller problems)
* Incremental (repeatedly improve an initial guess)

The course will progress through increasingly complex data structures:
* Numbers
* Linear structures (including multidimensional arrays)
* Trees
* Graphs
* Geometry

## Course Structure
The major components of the course are:
* Individual assignments that you are meant to complete on your own. You are welcome to help each other with *concepts*, but any code, writing, math, etc. should be your own.
* Team projects that you complete with a team of 3-4 students.
* Reading and reporting on a book about the social context of AI and machine learning. To keep discussions interesting, and to spare me the tedium of reading dozens of essays on the same book, each student will read a different book.

There are no exams. In place of a final exam, each student will give a very short (5 minute) presentation on the book they read. This will be accompanied by a class discussion.

## Schedule
Flex days are days for you to work on assignments in class. They also serve as a reserve in case of getting behind,
instructor illness, inclement weather, etc. Note the links to class notes above.

| Day | Date   | Lesson                                             |
|-----|--------|----------------------------------------------------|
| Wed | Sep 3  | What Makes a Program Fast?                         |
| Fri | Sep 5  | Syllabus and Setup                                 |
| Mon | Sep 8  | Fibonacci                                          |
| Wed | Sep 10 | Logarithms                                         |
| Fri | Sep 12 | Classes                                            |
| Mon | Sep 15 | Flex                                               |
| Wed | Sep 17 | Binary Representation                              |
| Fri | Sep 19 | Asymptotic Notation                                |
| Mon | Sep 22 | Array-Based and Linked Structures                  |
| Wed | Sep 24 | Stacks, Queues, Sets, and Dictionaries             |
| Fri | Sep 26 | Search                                             |
| Mon | Sep 29 | Sorting I                                          |
| Wed | Oct 1  | Sorting II                                         |
| Fri | Oct 3  | Sorting III                                        |
| Mon | Oct 6  | Flex                                               |
| Wed | Oct 8  | Pattern Matching                                   |
| Mon | Oct 13 | Hash Tables I                                      |
| Wed | Oct 15 | Hash Tables II                                     |
| Fri | Oct 17 | Matrix Multiplication                              |
| Mon | Oct 20 | Strassen's Algorithm                               |
| Wed | Oct 22 | Trees                                              |
| Fri | Oct 24 | Binary Search Trees                                |
| Mon | Oct 27 | Red-Black Trees                                    |
| Wed | Oct 29 | Priority Queues                                    |
| Fri | Oct 31 | Compression                                        |
| Mon | Nov 3  | Disjoint Sets                                      |
| Wed | Nov 5  | Flex                                               |
| Fri | Nov 7  | Graphs                                             |
| Mon | Nov 10 | Dijkstra's Algorithm                               |
| Wed | Nov 12 | Flex                                               |
| Fri | Nov 14 | The Floyd-Warshall Algorithm                       |
| Mon | Nov 17 | Flex                                               |
| Wed | Nov 19 | Topological Sorting                                |
| Fri | Nov 21 | Flex                                               |
| Mon | Nov 24 | The Kosaraju-Sharir Algorithm                      |
| Wed | Nov 26 | Flex                                               |
| Mon | Dec 1  | Minimum Spanning Trees                             |
| Wed | Dec 3  | Flex                                               |
| Fri | Dec 5  | Closest Pairs                                      |
| Mon | Dec 8  | Flex                                               |
| Wed | Dec 10 | Review                                             |
| Tue | Dec 16 | Final presentations and Scrabble smackdown, 1-4 PM |
